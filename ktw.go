package ktw

import (
	"bytes"
	"context"
	"html/template"
	"io"
	"strings"
	txt "text/template"

	elem "github.com/chasefleming/elem-go"
	"github.com/chasefleming/elem-go/attrs"
)

// Renderer implements the Render functionality of any components.
type Renderer interface {
	Render(context.Context, io.Writer) error
}

// Page represents a single Web page. It contains everything necessary to let
// the page's render function produce an HTML representation of the page and
// all its contents.
type Page struct {
	Title    string
	Metadata map[string]string
	Contents []Renderer

	// text.Template as we only use it to embed the Markdown rendered HTML
	// within `<< .Markdown >>`. The resulting document is also a template
	// and will be rendered using `package "html/template"` as a final pass
	// with the supplied meatadata.
	Template *txt.Template
}

func defaultTemplate(title string) (*txt.Template, error) {
	buf := &bytes.Buffer{}
	html := elem.Html(nil,
		elem.Head(nil,
			elem.Meta(attrs.Props{attrs.Charset: "utf-8"}),
			elem.Title(nil, elem.Text(title)),
			elem.Comment("Generated by Magic"),
		),
		elem.Body(nil, elem.Raw(`<< .Body >>`)),
	)
	_, err := buf.Write([]byte(html.Render()))
	if err != nil {
		return nil, err
	}
	return txt.New("").Delims("<<", ">>").Parse(buf.String())
}

// Render produces the HTML representing this page and all its contents.
//
// TODO: Use frontmatter style to create a template to evaluate with the
// frontmatter as input to the template. Find the template files by
// evaluating the provided, and parsed, configuration file.
func (p *Page) Render(ctx context.Context, w io.Writer) error {
	if p.Template == nil {
		tmpl, err := defaultTemplate(p.Title)
		if err != nil {
			return err
		}
		p.Template = tmpl
	}

	// Render all Markdown present.
	var body strings.Builder
	for _, item := range p.Contents {
		if err := item.Render(ctx, &body); err != nil {
			return err
		}
	}

	// Use text/template to render the template (provided or generated above).
	var buf bytes.Buffer
	if err := p.Template.Execute(&buf, struct{ Body string }{Body: body.String()}); err != nil {
		return err
	}

	// Treat the final document as an html/template document and render again.
	tmpl, err := template.New("").Parse(buf.String())
	if err != nil {
		return err
	}
	return tmpl.Execute(w, p)
}

// Interface guard.
var _ Renderer = (*Page)(nil)
